{"meta":{"title":"JOHOO'S BLOG","subtitle":null,"description":"Don't quit, you deserve what you want.","author":"Johoo","url":"https://johoo26.github.io"},"pages":[{"title":"About me","date":"2018-04-28T17:44:06.000Z","updated":"2018-11-08T15:36:29.832Z","comments":false,"path":"about/index.html","permalink":"https://johoo26.github.io/about/index.html","excerpt":"","text":"Born in Nanchang, Graduated from NJU, major in Life Science.Enthusiastic about coding, especially Python.Also interested in Big Data and Machine Learning."},{"title":"categories","date":"2018-04-29T03:57:46.000Z","updated":"2018-04-29T03:58:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://johoo26.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-29T04:01:04.000Z","updated":"2018-04-29T04:01:23.000Z","comments":true,"path":"tags/index.html","permalink":"https://johoo26.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Dive into Algorithm:quicksort","slug":"Dive-into-Algorithm-quicksort","date":"2018-12-25T05:32:41.000Z","updated":"2019-01-20T16:34:51.893Z","comments":true,"path":"2018/12/25/Dive-into-Algorithm-quicksort/","link":"","permalink":"https://johoo26.github.io/2018/12/25/Dive-into-Algorithm-quicksort/","excerpt":"","text":"本文为快速排序算法的Python实现。标准快排：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python3# coding=utf-8from tqdm import tqdmfrom copy import deepcopyimport randomimport stringdef partition(unsorted: list, begin: int, end: int) -&gt; int: v = unsorted[begin] i = begin + 1 j = end while True: while unsorted[i] &lt; v: if i == end: break i += 1 while unsorted[j] &gt; v: if j == begin: break j -= 1 if i &gt;= j: break unsorted[i], unsorted[j] = unsorted[j], unsorted[i] i += 1 j -= 1 unsorted[begin], unsorted[j] = unsorted[j], unsorted[begin] return jdef _quicksort(unsorted: list, begin: int, end: int): if begin &gt;= end: return j = partition(unsorted, begin, end) _quicksort(unsorted, begin, j - 1) _quicksort(unsorted, j + 1, end)def quicksort(unsorted_list: list) -&gt; list: random.shuffle(unsorted_list) begin, end = 0, len(unsorted_list) - 1 _quicksort(unsorted_list, begin, end) return unsorted_list if __name__ == '__main__': for _ in tqdm(range(100000)): l = list(map(int, (random.choice(string.digits) for i in range(random.randint(1, 100))))) assert sorted(deepcopy(l)) == quicksort(deepcopy(l)) 三切分法快排：123456789101112131415161718192021222324252627282930313233343536import random, stringfrom copy import deepcopyfrom tqdm import tqdmdef _quicksort(unsorted: list, begin: str, end: str): if begin &gt;= end: return lt, gt = begin, end v = unsorted[begin] i = begin + 1 while i &lt;= gt: if unsorted[i] &lt; v: unsorted[lt], unsorted[i] = unsorted[i], unsorted[lt] lt += 1 i += 1 elif unsorted[i] &gt; v: unsorted[i], unsorted[gt] = unsorted[gt], unsorted[i] gt -= 1 else: i += 1 _quicksort(unsorted, begin, lt - 1) _quicksort(unsorted, gt + 1, end)def quicksort(unsorted_list:list) -&gt; list: random.shuffle(unsorted_list) begin, end = 0, len(unsorted_list) - 1 _quicksort(unsorted_list, begin, end) return unsorted_listif __name__ == '__main__': for _ in tqdm(range(100000)): l = list(map(int, (random.choice(string.digits) for i in range(random.randint(1, 100))))) assert sorted(deepcopy(l)) == quicksort(deepcopy(l)) 三切分还是更快一些的，因为一次可以排定多个值，而标准快排一次只能排定一个值。而且三切分法写起来也简单一些…","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://johoo26.github.io/tags/Algorithm/"}],"keywords":[]},{"title":"Dive into Python: singleton","slug":"Dive-into-Python-singleton","date":"2018-12-18T15:25:08.000Z","updated":"2018-12-22T17:26:20.435Z","comments":true,"path":"2018/12/18/Dive-into-Python-singleton/","link":"","permalink":"https://johoo26.github.io/2018/12/18/Dive-into-Python-singleton/","excerpt":"","text":"今天讲一下在Python中实现单例模式的一些方法以及对应讨论。 装饰器 123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# coding=utf-8from functools import wrapsimport threadinglock = threading.Lock()def singleton(cls): instances = &#123;&#125; @wraps(cls) def wrapper(*args, **kwargs): with lock: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper@singletonclass MyClass: def __init__(self, *args, **kwargs): print('MyClass.__init__ called.') self.args = args self.kwargs = kwargs @classmethod def cls_method(cls, *args, **kwargs): print('Myclass classmethod called.') 测试一下： 12345678910111213In [2]: a = MyClass(1, 2)MyClass.__init__ called.In [3]: b = MyClass(3,4,5)In [4]: a is bOut[4]: TrueIn [5]: a.__dict__Out[5]: &#123;'args': (1, 2), 'kwargs': &#123;&#125;&#125;In [6]: b.__dict__Out[6]: &#123;'args': (1, 2), 'kwargs': &#123;&#125;&#125; 可见a和b两个实例其实是一个对象，Myclass只被调用了一次。加锁的目的是为了达到线程安全，防止在操作instances字典的时候被其他线程抢占到时间片执行而重复创建实例。这种方式确实实现了单例模式，但是MyClass现在变成一个函数了，所以不能直接用MyClass调用cls_method了，只能通过实例调用… 12345678910In [7]: MyClass.cls_method()---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-7-7bcbf0e7bf90&gt; in &lt;module&gt;()----&gt; 1 MyClass.cls_method()TypeError: 'classmethod' object is not callableIn [8]: a.cls_method()Myclass classmethod called. 模块导入 第二种方法是在一个独立模块中创建好实例后导入，由于Python不会重复导入已经导入的对象，因此这样也能实现单例模式: 12345678910111213141516171819# one.pyprint('one.py imported by others.')class Foobar: def __init__(self, *args, **kwargs): self.args = args self.kwargs = kwargsfoo = Foobar(1, '2', x=3)# two.pyfrom one import fooprint(id(foo))from one import fooprint(id(foo)) 运行two.py: 1234❯ python3 two.py one.py imported by others.140485279112104140485279112104 这样做的优点是简单，缺点和装饰器一样，只能通过实例来调用classmethod. __new__ 第三种，改写__new__方法: 123456789101112131415import threadingclass Singleton: instances = &#123;&#125; lock = threading.Lock() def __new__(cls, *args, **kwargs): with cls.lock: if cls not in cls.instances: cls.instances[cls] = super().__new__(cls) return cls.instances[cls] def __init__(self, *args, **kwargs): self.args = args self.kwargs = kwargs 测试： 123456789101112131415161718In [2]: a = Singleton(1, '2', x=3)In [3]: b = Singleton(3, '4', y=5)In [4]: a is bOut[4]: TrueIn [5]: aOut[5]: &lt;one.Singleton at 0x7f7132af6550&gt;In [6]: bOut[6]: &lt;one.Singleton at 0x7f7132af6550&gt;In [7]: a.__dict__Out[7]: &#123;'args': (3, '4'), 'kwargs': &#123;'y': 5&#125;&#125;In [8]: b.__dict__Out[8]: &#123;'args': (3, '4'), 'kwargs': &#123;'y': 5&#125;&#125; 前后两个实例是同一个，这点证明确实是单例模式了，但为什么a的属性变了？这个问题，在第四种方法中一并解释。这种方法的缺点是，如果子类改写了__new__方法，那么单例模式就失效了，比如：123456789101112131415161718192021222324import threadingclass Singleton: instances = &#123;&#125; lock = threading.Lock() def __new__(cls, *args, **kwargs): if cls not in cls.instances: cls.instances[cls] = super().__new__(cls) return cls.instances[cls] def __init__(self, *args, **kwargs): self.args = args self.kwargs = kwargsclass Subclass(Singleton): def __new__(cls, *args, **kwargs): return object.__new__(cls) def __init__(self, *args, **kwargs): self.args = args self.kwargs = kwargs 测试：123456789101112In [2]: a = Subclass(1, '2', x=3)In [3]: b = Subclass(3, '4', y=5)In [4]: aOut[4]: &lt;one.Subclass at 0x7fe97ad65e80&gt;In [5]: bOut[5]: &lt;one.Subclass at 0x7fe97add2a20&gt;In [6]: a is bOut[6]: False metaclass第四种方法，使用元类：123456789101112131415161718import threadingclass Meta(type): instances = &#123;&#125; lock = threading.Lock() def __call__(cls, *args, **kwargs): with cls.lock: if cls not in cls.instances: cls.instances[cls] = super().__call__(*args, **kwargs) return cls.instances[cls]class Singleton(metaclass=Meta): def __init__(self, *args, **kwargs): self.args = args self.kwargs = kwargs 测试：123456789101112In [2]: a = Singleton(1, '2', x=3)In [3]: b = Singleton(3, '4', y=5)In [4]: a is bOut[4]: TrueIn [5]: a.__dict__Out[5]: &#123;'args': (1, '2'), 'kwargs': &#123;'x': 3&#125;&#125;In [6]: b.__dict__Out[6]: &#123;'args': (1, '2'), 'kwargs': &#123;'x': 3&#125;&#125; 可以看到，a和b是同一个对象，确实是单例模式，但是跟第三种方法不同的是，实例属性是以第一次调用为准，为什么呢？这个过程有点复杂，看以下图片： 实例完整的创建过程是这样的： 1.调用Metaclass.__call__ 2.Metaclass.__call__调用Class.__new__创建instance 3.Metaclass.__call__以instance和其他参数去调用Class.__init__进行初始化 4.Metaclass.__call__返回instance 在第四种方法，实例已经创建后，就不会再去调用Class.__new__创建实例和Class.__init__进行初始化了，因此实例属性由第一次创建决定。而第三种方法，虽然Class.__new__不会重复创建实例，但是Class.__init__还是会被调用，因此属性随最后一次而定。使用元类的好处是，元类会附着到子类上，单例模式不会因为继承而失效：1234567891011121314class Meta(type): passclass SupClass(metaclass=Meta): passclass SubClass(SupClass): passprint(type(SupClass), type(SubClass))运行结果：&lt;class '__main__.Meta'&gt; &lt;class '__main__.Meta'&gt; 因此，以上四种方法，元类的解决方案是最好的！","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"}],"keywords":[]},{"title":"Dive into flask: principle of Context","slug":"Dive-into-flask-principle-of-Context","date":"2018-12-04T16:43:57.000Z","updated":"2018-12-06T14:11:22.568Z","comments":true,"path":"2018/12/05/Dive-into-flask-principle-of-Context/","link":"","permalink":"https://johoo26.github.io/2018/12/05/Dive-into-flask-principle-of-Context/","excerpt":"","text":"先看以下一段代码：123456789101112# analyze_flask.py# coding=utf-8from flask import Flask, requestapp = Flask(__name__)@app.route('/hello/&lt;name&gt;', methods=['POST', 'GET'])def index(name): if request.method == 'POST': return 'post date:&#123;&#125;'.format(request.form['date']) return 'get date:&#123;&#125;'.format(request.args['date']) 启动服务：1gunicorn -w 1 -b 0.0.0.0:8000 analyze_flask:app 发送请求：12345678910111213141516171819❯ http GET http://0.0.0.0:8000/hello/josh\\?date\\='yesterday'HTTP/1.1 200 OKConnection: closeContent-Length: 18Content-Type: text/html; charset=utf-8Date: Thu, 06 Dec 2018 00:14:47 GMTServer: gunicorn/19.9.0get date:yesterday http --form POST http://0.0.0.0:8000/hello/josh date='today'HTTP/1.1 200 OKConnection: closeContent-Length: 15Content-Type: text/html; charset=utf-8Date: Thu, 06 Dec 2018 00:14:52 GMTServer: gunicorn/19.9.0post date:today 要知道request可是在启动服务器的时候就定义好的，为什么它能未卜先知获得将来的请求的信息呢？依旧，从源码中找寻答案。request的定义是在flask/globals.py中：12345678910111213141516171819202122232425262728def _lookup_req_object(name): top = _request_ctx_stack.top if top is None: raise RuntimeError(_request_ctx_err_msg) return getattr(top, name)def _lookup_app_object(name): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return getattr(top, name)def _find_app(): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return top.app# context locals_request_ctx_stack = LocalStack()_app_ctx_stack = LocalStack()current_app = LocalProxy(_find_app)request = LocalProxy(partial(_lookup_req_object, 'request'))session = LocalProxy(partial(_lookup_req_object, 'session'))g = LocalProxy(partial(_lookup_app_object, 'g')) request是LocalProxy的实例对象，传给构造器的参数是一个偏函数：partial(_lookup_req_object, ‘request’).我们先看下这个偏函数，然后再来看LocalProxy.partial(_lookup_req_object, ‘request’)的作用，根据代码猜测，应该是获取_request_ctx_stack栈顶对象的request属性。因此要搞清楚这个栈的相关信息。123456# werkzeug/local.pyclass LocalStack(object): def __init__(self): self._local = Local() LocalStack的push, top, pop等操作最终都是落在self._local上，这是Local的实例：12345678# werkzeug/local.pyclass Local(object): __slots__ = ('__storage__', '__ident_func__') def __init__(self): object.__setattr__(self, '__storage__', &#123;&#125;) object.__setattr__(self, '__ident_func__', get_ident) 这里涉及到一个get_ident的函数:123456789101112# werkzeug/local.py# since each thread has its own greenlet we can just use those as identifiers# for the context. If greenlets are not available we fall back to the# current thread ident depending on where it is.try: from greenlet import getcurrent as get_identexcept ImportError: try: from thread import get_ident except ImportError: from _thread import get_ident get_ident的作用是获取线程的唯一身份标识。Local中还定义了一个self.__storage__的实例属性，初始值是空字典。重点来了：123456789101112131415161718192021class Local(object): def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; def __delattr__(self, name): try: del self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) Local实现了三个魔法方法：__getattr__, __setattr__, __delattr__，在操作self.__storage__这个字典时，以self.__ident_func__()的结果–即线程的唯一标识作为字典的键，因此不同的请求之间就被彻底隔离了， 每个请求只会访问到自己的数据。回到LocalStack:1234567891011121314151617181920212223242526272829303132333435class LocalStack(object): def _get__ident_func__(self): return self._local.__ident_func__ def push(self, obj): \"\"\"Pushes a new item to the stack\"\"\" rv = getattr(self._local, 'stack', None) if rv is None: self._local.stack = rv = [] rv.append(obj) return rv def pop(self): \"\"\"Removes the topmost item from the stack, will return the old value or `None` if the stack was already empty. \"\"\" stack = getattr(self._local, 'stack', None) if stack is None: return None elif len(stack) == 1: release_local(self._local) return stack[-1] else: return stack.pop() @property def top(self): \"\"\"The topmost item on the stack. If the stack is empty, `None` is returned. \"\"\" try: return self._local.stack[-1] except (AttributeError, IndexError): return None 执行LocalStack的push方法时，会给self._local设置stack属性，其初始值是一个列表，要压入栈中的对象就是append到这个列表中了。同理，执行pop, top方法，也是从这个列表中删除或者获取最后压入的对象。这些操作都是线程安全的。到这一步，我们搞清楚了_request_ctx_stack, _app_ctx_stack这两个栈的属性，它们是在哪里被使用的呢？其实上一篇博客中，解释一个完整的请求过程时有涉及到：1234567891011121314151617181920212223242526272829303132333435363738394041424344# flask/ctx.pyclass RequestContext(object): def __init__(self, app, environ, request=None): self.app = app if request is None: request = app.request_class(environ) self.request = request self.session = None def push(self): top = _request_ctx_stack.top if top is not None and top.preserved: top.pop(top._preserved_exc) # Before we push the request context we have to ensure that there # is an application context. app_ctx = _app_ctx_stack.top if app_ctx is None or app_ctx.app != self.app: app_ctx = self.app.app_context() app_ctx.push() self._implicit_app_ctx_stack.append(app_ctx) else: self._implicit_app_ctx_stack.append(None) _request_ctx_stack.push(self) class AppContext(object): def __init__(self, app): self.app = app self.url_adapter = app.create_url_adapter(None) self.g = app.app_ctx_globals_class() def push(self): \"\"\"Binds the app context to the current context.\"\"\" self._refcnt += 1 if hasattr(sys, 'exc_clear'): sys.exc_clear() _app_ctx_stack.push(self) appcontext_pushed.send(self.app) 请求进来后，进行解析匹配，接着往_request_ctx_stack中压入的是RequestContext的实例对象，_app_ctx_stack中压入的是AppContext的实例对象。到这里，真相快出来了。回到LocalProxy:1234567891011121314151617181920212223242526class LocalProxy(object): def __init__(self, local, name=None): object.__setattr__(self, '_LocalProxy__local', local) object.__setattr__(self, '__name__', name) if callable(local) and not hasattr(local, '__release_local__'): # \"local\" is a callable that is not an instance of Local or # LocalManager: mark it as a wrapped function. object.__setattr__(self, '__wrapped__', local) def _get_current_object(self): \"\"\"Return the current object. This is useful if you want the real object behind the proxy at a time for performance reasons or because you want to pass the object into a different context. \"\"\" if not hasattr(self.__local, '__release_local__'): return self.__local() try: return getattr(self.__local, self.__name__) except AttributeError: raise RuntimeError('no object bound to %s' % self.__name__) def __getattr__(self, name): if name == '__members__': return dir(self._get_current_object()) return getattr(self._get_current_object(), name) request是LocalProxy的实例对象，传给构造器的参数是偏函数(partial(_lookup_req_object, ‘request’).因此在获取request的相关属性时，比如：123if request.method == 'POST': return 'post date:&#123;&#125;'.format(request.form['date'])return 'get date:&#123;&#125;'.format(request.args['date']) 其实是调用LocalProxy的__getattr__方法，而self._get_current_object()的结果正是以上传入构造器的偏函数的返回值，即_request_ctx_stack栈顶对象的request属性，所以__getattr__的作用就是从当前栈顶对象的request上获取想要查询的属性。request这个上下文变量的原理解释完了。其他三个上下文变量session, g, current_app的实现也是一样的， 细心的话你应该能够发现本文已经都讲了。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://johoo26.github.io/tags/Flask/"}],"keywords":[]},{"title":"Dive into flask: journey of one request","slug":"Dive-into-flask-the-journey-of-one-request","date":"2018-11-30T05:21:05.000Z","updated":"2018-12-02T11:39:18.423Z","comments":true,"path":"2018/11/30/Dive-into-flask-the-journey-of-one-request/","link":"","permalink":"https://johoo26.github.io/2018/11/30/Dive-into-flask-the-journey-of-one-request/","excerpt":"","text":"一直对Flask的实现机制很好奇，本着知其然更要知其所以然的态度，我将基于一个简单的HTTP请求来分析分析Flask的源码，看看是如何从请求变成响应的。 Flask是基于WSGI协议实现的Python Web开发框架，我不会介绍什么是WSGI协议，请看: https://www.python.org/dev/peps/pep-3333/ 一个典型的flask application如下： 12345678910111213141516from flask import Flaskapp = Flask(__name__)@app.route('/hello/&lt;name&gt;')def index(name): return \"hello &#123;&#125;\".format(name)@app.route('/hi')def hi(): return 'hi~' if __name__ == '__main__': app.run(host='0.0.0.0', port=8000) 基本过程如下： 创建Flask类的实例，即app这个应用； 用app.route装饰器来构建url映射； 收到请求，确定对应的视图函数，调用视图函数得到响应并返回给服务器，而后再由服务器返回给客户端，一次请求结束。 1app = Flask(__name__) 以上这一步做了什么？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# flask/app.pyclass Flask(_PackageBoundObject): #: The class that is used for request objects. See :class:`~flask.Request` #: for more information. request_class = Request #: The class that is used for response objects. See #: :class:`~flask.Response` for more information. response_class = Response #: The rule object to use for URL rules created. This is used by #: :meth:`add_url_rule`. Defaults to :class:`werkzeug.routing.Rule`. #: #: .. versionadded:: 0.7 url_rule_class = Rule def __init__( self, import_name, static_url_path=None, static_folder='static', static_host=None, host_matching=False, subdomain_matching=False, template_folder='templates', instance_path=None, instance_relative_config=False, root_path=None ): _PackageBoundObject.__init__( self, import_name, template_folder=template_folder, root_path=root_path ) ...... #: A dictionary of all view functions registered. The keys will #: be function names which are also used to generate URLs and #: the values are the function objects themselves. #: To register a view function, use the :meth:`route` decorator. self.view_functions = &#123;&#125; #: A dictionary with lists of functions that will be called at the #: beginning of each request. The key of the dictionary is the name of #: the blueprint this function is active for, or ``None`` for all #: requests. To register a function, use the :meth:`before_request` #: decorator. self.before_request_funcs = &#123;&#125; #: A list of functions that will be called at the beginning of the #: first request to this instance. To register a function, use the #: :meth:`before_first_request` decorator. #: #: .. versionadded:: 0.8 self.before_first_request_funcs = [] #: A dictionary with lists of functions that should be called after #: each request. The key of the dictionary is the name of the blueprint #: this function is active for, ``None`` for all requests. This can for #: example be used to close database connections. To register a function #: here, use the :meth:`after_request` decorator. self.after_request_funcs = &#123;&#125; #: The :class:`~werkzeug.routing.Map` for this instance. You can use #: this to change the routing converters after the class was created #: but before any routes are connected. Example:: #: #: from werkzeug.routing import BaseConverter #: #: class ListConverter(BaseConverter): #: def to_python(self, value): #: return value.split(',') #: def to_url(self, values): #: return ','.join(super(ListConverter, self).to_url(value) #: for value in values) #: #: app = Flask(__name__) #: app.url_map.converters['list'] = ListConverter self.url_map = Map() 实际做的东西还有很多，我只把其中关键的一些拎出来了 。 我们传入给flask.Flask的__name__作为import_name, 其作用是定义app的默认root_path, 用来为一系列配置资源定位。 flask.Flask定义了很多东西： request_class: 请求类 response_class: 响应类 url_rule_class: URL规则类 self.view_functions: 映射 端点视图函数 的字典 self.before_request_funcs: 存放每次请求前要执行的函数 self.before_first_request_funcs: 存放一系列在app的第一个请求之前需要执行的函数 self.after_request_funcs: 存放每次请求后要执行的函数 self.url_map: 规则的映射类 123@app.route('/hello/&lt;name&gt;')def index(name): return \"hello &#123;&#125;\".format(name) 这一步又做了什么？ 用app.route这个带参数的装饰器来修饰index函数。app.route的代码如下： 12345678910111213141516171819202122232425262728293031# flask/app.py def route(self, rule, **options): \"\"\"A decorator that is used to register a view function for a given URL rule. This does the same thing as :meth:`add_url_rule` but is intended for decorator usage:: @app.route('/') def index(): return 'Hello World' For more information refer to :ref:`url-route-registrations`. :param rule: the URL rule as string :param endpoint: the endpoint for the registered URL rule. Flask itself assumes the name of the view function as endpoint :param options: the options to be forwarded to the underlying :class:`~werkzeug.routing.Rule` object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (``GET``, ``POST`` etc.). By default a rule just listens for ``GET`` (and implicitly ``HEAD``). Starting with Flask 0.6, ``OPTIONS`` is implicitly added and handled by the standard request handling. \"\"\" def decorator(f): endpoint = options.pop('endpoint', None) self.add_url_rule(rule, endpoint, f, **options) return f return decorator decorator内调用add_url_rule方法，并原样返回f, 因此路由函数没有任何改变。那么add_url_rule做了什么呢？看看它的代码： 1234567891011121314151617181920212223242526272829 def add_url_rule(self, rule, endpoint=None, view_func=None, provide_automatic_options=None, **options): if endpoint is None: endpoint = _endpoint_from_view_func(view_func) options['endpoint'] = endpoint methods = options.pop('methods', None) # if the methods are not given and the view_func object knows its # methods we can use that instead. If neither exists, we go with # a tuple of only ``GET`` as default. if methods is None: methods = getattr(view_func, 'methods', None) or ('GET',) if isinstance(methods, string_types): raise TypeError('Allowed methods have to be iterables of strings, ' 'for example: @app.route(..., methods=[\"POST\"])') methods = set(item.upper() for item in methods)...... rule = self.url_rule_class(rule, methods=methods, **options) rule.provide_automatic_options = provide_automatic_options self.url_map.add(rule) if view_func is not None: old_func = self.view_functions.get(endpoint) if old_func is not None and old_func != view_func: raise AssertionError('View function mapping is overwriting an ' 'existing endpoint function: %s' % endpoint) self.view_functions[endpoint] = view_func 先确定endpoint和methods, 然后构建werkzeug/routing.Rule类的实例rule, 并以rule为参数调用self.url_map的add方法，之后就是简单的在self.view_functions字典中以endpoint为键，view_func为值建立映射。关键的地方就这两步了: 构建werkzeug/routing.Rule类的实例rule 以rule为参数调用self.url_map的add方法 werkzeug/routing.Rule的构造函数是这样的: 123456789101112131415161718192021222324252627282930313233class Rule(RuleFactory): def __init__(self, string, defaults=None, subdomain=None, methods=None, build_only=False, endpoint=None, strict_slashes=None, redirect_to=None, alias=False, host=None): if not string.startswith('/'): raise ValueError('urls must start with a leading slash') self.rule = string self.is_leaf = not string.endswith('/') self.map = None self.strict_slashes = strict_slashes self.subdomain = subdomain self.host = host self.defaults = defaults self.build_only = build_only self.alias = alias if methods is None: self.methods = None else: if isinstance(methods, str): raise TypeError('param `methods` should be `Iterable[str]`, not `str`') self.methods = set([x.upper() for x in methods]) if 'HEAD' not in self.methods and 'GET' in self.methods: self.methods.add('HEAD') self.endpoint = endpoint self.redirect_to = redirect_to if defaults: self.arguments = set(map(str, defaults)) else: self.arguments = set() self._trace = self._converters = self._regex = self._argument_weights = None 依旧是定义了很多属性，着重留意这几个: self.rule, self.endpoint, self._regex. 而werkzeug/routing.Map的add函数代码如下: 1234567891011121314151617181920212223242526272829303132333435363738class Map(object): def __init__(self, rules=None, default_subdomain='', charset='utf-8', strict_slashes=True, redirect_defaults=True, converters=None, sort_parameters=False, sort_key=None, encoding_errors='replace', host_matching=False): self._rules = [] self._rules_by_endpoint = &#123;&#125; self._remap = True self._remap_lock = Lock() self.default_subdomain = default_subdomain self.charset = charset self.encoding_errors = encoding_errors self.strict_slashes = strict_slashes self.redirect_defaults = redirect_defaults self.host_matching = host_matching self.converters = self.default_converters.copy() if converters: self.converters.update(converters) self.sort_parameters = sort_parameters self.sort_key = sort_key for rulefactory in rules or (): self.add(rulefactory) def add(self, rulefactory): \"\"\"Add a new rule or factory to the map and bind it. Requires that the rule is not bound to another map. :param rulefactory: a :class:`Rule` or :class:`RuleFactory` \"\"\" for rule in rulefactory.get_rules(self): rule.bind(self) self._rules.append(rule) self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule) self._remap = True add的关键，是rule.bind，而后再添加rule到self._rules和self._rules_by_endpoint这两个属性. 回到werkzeug/routing.Rule的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Rule(RuleFactory): def bind(self, map, rebind=False): \"\"\"Bind the url to a map and create a regular expression based on the information from the rule itself and the defaults from the map. :internal: \"\"\" if self.map is not None and not rebind: raise RuntimeError('url rule %r already bound to map %r' % (self, self.map)) self.map = map if self.strict_slashes is None: self.strict_slashes = map.strict_slashes if self.subdomain is None: self.subdomain = map.default_subdomain self.compile() def compile(self): \"\"\"Compiles the regular expression and stores it.\"\"\" assert self.map is not None, 'rule not bound' if self.map.host_matching: domain_rule = self.host or '' else: domain_rule = self.subdomain or '' self._trace = [] self._converters = &#123;&#125; self._static_weights = [] self._argument_weights = [] regex_parts = [] def _build_regex(rule): index = 0 for converter, arguments, variable in parse_rule(rule): if converter is None: regex_parts.append(re.escape(variable)) self._trace.append((False, variable)) for part in variable.split('/'): if part: self._static_weights.append((index, -len(part))) else: if arguments: c_args, c_kwargs = parse_converter_args(arguments) else: c_args = () c_kwargs = &#123;&#125; convobj = self.get_converter( variable, converter, c_args, c_kwargs) regex_parts.append('(?P&lt;%s&gt;%s)' % (variable, convobj.regex)) self._converters[variable] = convobj self._trace.append((True, variable)) self._argument_weights.append(convobj.weight) self.arguments.add(str(variable)) index = index + 1 _build_regex(domain_rule) regex_parts.append('\\\\|') self._trace.append((False, '|')) _build_regex(self.is_leaf and self.rule or self.rule.rstrip('/')) if not self.is_leaf: self._trace.append((False, '/')) if self.build_only: return regex = r'^%s%s$' % ( u''.join(regex_parts), (not self.is_leaf or not self.strict_slashes) and '(?&lt;!/)(?P&lt;__suffix__&gt;/?)' or '' ) self._regex = re.compile(regex, re.UNICODE) 可见，URL的模式是以正则表达式来匹配的。’/hello/\\‘ 这个rule对应的正则是： 1re.compile('^\\\\|\\\\/hello\\\\/(?P&lt;name&gt;[^/]&#123;1,&#125;)$') 这时候的flask/app.Flask self.url_map属性如下: 1&#123;'_rules': [&lt;Rule '/static/&lt;filename&gt;' (HEAD, GET, OPTIONS) -&gt; static&gt;, &lt;Rule '/hello/&lt;name&gt;' (HEAD, GET, OPTIONS) -&gt; index&gt;], '_rules_by_endpoint': &#123;'static': [&lt;Rule '/static/&lt;filename&gt;' (HEAD, GET, OPTIONS) -&gt; static&gt;], 'index': [&lt;Rule '/hello/&lt;name&gt;' (HEAD, GET, OPTIONS) -&gt; index&gt;]&#125;, '_remap': True, '_remap_lock': &lt;unlocked _thread.lock object at 0x7f9c60af1af8&gt;, 'default_subdomain': '', 'charset': 'utf-8', 'encoding_errors': 'replace', 'strict_slashes': True, 'redirect_defaults': True, 'host_matching': False, 'converters': &#123;'default': &lt;class 'werkzeug.routing.UnicodeConverter'&gt;, 'string': &lt;class 'werkzeug.routing.UnicodeConverter'&gt;, 'any': &lt;class 'werkzeug.routing.AnyConverter'&gt;, 'path': &lt;class 'werkzeug.routing.PathConverter'&gt;, 'int': &lt;class 'werkzeug.routing.IntegerConverter'&gt;, 'float': &lt;class 'werkzeug.routing.FloatConverter'&gt;, 'uuid': &lt;class 'werkzeug.routing.UUIDConverter'&gt;&#125;, 'sort_parameters': False, 'sort_key': None&#125; 至此，urlpattern -&gt; endpoint -&gt; view_func的链条就建立好了，收到请求后就是按照这个链条去找到对应的视图函数进行处理进而给出响应的。 现在可以开始分析请求的处理过程了 根据WSGI规范，应用必须是一个可调用对象，接受服务器传入的environ和start_response两个参数，我们看一下flask.app.Flask的代码: 123456def __call__(self, environ, start_response): \"\"\"The WSGI server calls the Flask application object as the WSGI application. This calls :meth:`wsgi_app` which can be wrapped to applying middleware.\"\"\" response = self.wsgi_app(environ, start_response) return response Flask类实现了__call__这个方法, 并且把实际的处理转移到了wsgi_app方法中，继续刨: 123456789101112131415161718def wsgi_app(self, environ, start_response): ctx = self.request_context(environ) error = None try: try: ctx.push() response = self.full_dispatch_request() except Exception as e: error = e response = self.handle_exception(e) except: error = sys.exc_info()[1] raise return response(environ, start_response) finally: if self.should_ignore_error(error): error = None ctx.auto_pop(error) 主要是这几步: ctx = self.request_context(environ) – 解析请求上下文 ctx.push() – 将请求上下文推入栈中 response = self.full_dispatch_request() – 分派处理并得到响应 return response(environ, start_response) – 响应发送给服务器 其他的异常处理就不说了。 逐一来分析以上4个步骤: 解析请求上下文先启动服务器: 1gunicorn -w 1 -b 0.0.0.0:8000 analyze_flask:app 请求http://0.0.0.0:8000/hello/flask ，打印出environ变量: 1&#123;'wsgi.errors': &lt;gunicorn.http.wsgi.WSGIErrorsWrapper object at 0x7f11a2eea908&gt;, 'wsgi.version': (1, 0), 'wsgi.multithread': False, 'wsgi.multiprocess': False, 'wsgi.run_once': False, 'wsgi.file_wrapper': &lt;class 'gunicorn.http.wsgi.FileWrapper'&gt;, 'SERVER_SOFTWARE': 'gunicorn/19.9.0', 'wsgi.input': &lt;gunicorn.http.body.Body object at 0x7f11a2eea710&gt;, 'gunicorn.socket': &lt;socket.socket fd=9, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000), raddr=('127.0.0.1', 60080)&gt;, 'REQUEST_METHOD': 'GET', 'QUERY_STRING': '', 'RAW_URI': '/hello/flask', 'SERVER_PROTOCOL': 'HTTP/1.1', 'HTTP_HOST': '0.0.0.0:8000', 'HTTP_CONNECTION': 'keep-alive', 'HTTP_CACHE_CONTROL': 'max-age=0', 'HTTP_UPGRADE_INSECURE_REQUESTS': '1', 'HTTP_USER_AGENT': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/70.0.3538.77 Chrome/70.0.3538.77 Safari/537.36', 'HTTP_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'HTTP_ACCEPT_ENCODING': 'gzip, deflate', 'HTTP_ACCEPT_LANGUAGE': 'en-US,en;q=0.9,zh-CN;q=0.8,zh-TW;q=0.7,zh;q=0.6', 'wsgi.url_scheme': 'http', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '60080', 'SERVER_NAME': '0.0.0.0', 'SERVER_PORT': '8000', 'PATH_INFO': '/hello/flask', 'SCRIPT_NAME': ''&#125; 这个是很重要的哈，因为解析请求上下文要用到的参数就是environ: 1234567891011121314151617# flask/app.py def request_context(self, environ): \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a WSGI environment. Use a ``with`` block to push the context, which will make :data:`request` point at this request. See :doc:`/reqcontext`. Typically you should not call this from your own code. A request context is automatically pushed by the :meth:`wsgi_app` when handling a request. Use :meth:`test_request_context` to create an environment and context instead of this method. :param environ: a WSGI environment \"\"\" return RequestContext(self, environ) 所以, ctx = self.request_context(environ)中的ctx变量其实就是flask/ctx.RequestContext这个类的实例, 类的构造函数如下: 1234567891011# flask/ctx.pyclass RequestContext(object): def __init__(self, app, environ, request=None): self.app = app if request is None: request = app.request_class(environ) self.request = request self.url_adapter = app.create_url_adapter(self.request) self.match_request() ...... a)先是用environ去构造flask/wrappers.Request的实例: request b)接着要求出url调制器: url_adapter c)最后是匹配请求，看命中的是哪一个urlpattern a没什么好讲的，看下b这步: 12345678910111213141516171819202122232425262728293031323334# flask/app.py def create_url_adapter(self, request): \"\"\"Creates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly. .. versionadded:: 0.6 .. versionchanged:: 0.9 This can now also be called without a request object when the URL adapter is created for the application context. .. versionchanged:: 1.0 :data:`SERVER_NAME` no longer implicitly enables subdomain matching. Use :attr:`subdomain_matching` instead. \"\"\" if request is not None: # If subdomain matching is disabled (the default), use the # default subdomain in all cases. This should be the default # in Werkzeug but it currently does not have that feature. subdomain = ((self.url_map.default_subdomain or None) if not self.subdomain_matching else None) return self.url_map.bind_to_environ( request.environ, server_name=self.config['SERVER_NAME'], subdomain=subdomain) # We need at the very least the server name to be set for this # to work. if self.config['SERVER_NAME'] is not None: return self.url_map.bind( self.config['SERVER_NAME'], script_name=self.config['APPLICATION_ROOT'], url_scheme=self.config['PREFERRED_URL_SCHEME']) 因为我们的request不是None， 所以走的是这一步: 1234return self.url_map.bind_to_environ( request.environ, server_name=self.config['SERVER_NAME'], subdomain=subdomain) 又要看werkzeug/routing.Map的代码了: 123456789101112131415class Map(object): def bind_to_environ(self, environ, server_name=None, subdomain=None): ...... return Map.bind(self, server_name, script_name, subdomain, environ['wsgi.url_scheme'], environ['REQUEST_METHOD'], path_info, query_args=query_args) def bind(self, server_name, script_name=None, subdomain=None, url_scheme='http', default_method='GET', path_info=None, query_args=None): ...... return MapAdapter(self, server_name, script_name, subdomain, url_scheme, path_info, default_method, query_args) 看来最终b这一步得到的是MapAdapter这个类的实例，其构造函数如下: 12345678910111213141516171819class MapAdapter(object): \"\"\"Returned by :meth:`Map.bind` or :meth:`Map.bind_to_environ` and does the URL matching and building based on runtime information. \"\"\" def __init__(self, map, server_name, script_name, subdomain, url_scheme, path_info, default_method, query_args=None): self.map = map self.server_name = to_unicode(server_name) script_name = to_unicode(script_name) if not script_name.endswith(u'/'): script_name += u'/' self.script_name = script_name self.subdomain = to_unicode(subdomain) self.url_scheme = to_unicode(url_scheme) self.path_info = to_unicode(path_info) self.default_method = to_unicode(default_method) self.query_args = query_args 轮到c这一步了，match_request: 123456789101112class RequestContext(object): ...... def match_request(self): \"\"\"Can be overridden by a subclass to hook into the matching of the request. \"\"\" try: url_rule, self.request.view_args = \\ self.url_adapter.match(return_rule=True) self.request.url_rule = url_rule except HTTPException as e: self.request.routing_exception = e 要调用self.url_adapter的match方法进行匹配，并指定返回rule(关键字参数return_rule=True): 123456789101112131415161718192021222324252627282930313233class MapAdapter(object): ...... def match(self, path_info=None, method=None, return_rule=False, query_args=None): if path_info is None: path_info = self.path_info else: path_info = to_unicode(path_info, self.map.charset) if query_args is None: query_args = self.query_args method = (method or self.default_method).upper() path = u'%s|%s' % ( self.map.host_matching and self.server_name or self.subdomain, path_info and '/%s' % path_info.lstrip('/') ) for rule in self.map._rules: try: rv = rule.match(path, method) except RequestSlash: raise RequestRedirect(self.make_redirect_url( url_quote(path_info, self.map.charset, safe='/:|+') + '/', query_args)) except RequestAliasRedirect as e: raise RequestRedirect(self.make_alias_redirect_url( path, rule.endpoint, e.matched_values, method, query_args)) if rv is None: continue ...... if return_rule: return rule, rv else: return rule.endpoint, rv 核心是构建path，遍历Map中每一个rule, 调用rule.match方法进行匹配。 又要回到werkzeug/routing.Rule了: 123456789101112131415class Rule(RuleFactory): ...... def match(self, path, method=None): if not self.build_only: m = self._regex.search(path) if m is not None: groups = m.groupdict() result = &#123;&#125; for name, value in iteritems(groups): try: value = self._converters[name].to_python(value) except ValidationError: return result[str(name)] = value return result 在Rule.match中，用rule._regex去匹配path, 如果匹配到，则返回请求参数这个字典，否则返回None.回忆一下我们构建的map._rules有哪些:1&#123;'_rules': [&lt;Rule '/static/&lt;filename&gt;' (HEAD, GET, OPTIONS) -&gt; static&gt;, &lt;Rule '/hello/&lt;name&gt;' (HEAD, GET, OPTIONS) -&gt; index&gt;, &lt;Rule '/hi' (HEAD, GET, OPTIONS) -&gt; hi&gt;]&#125; 在MapAdapter中，如果匹配到就直接return rule, rv, 否则就尝试匹配下一个rule.ok, 步骤c终于完了。现在，我们知道请求命中的是哪一个rule, 请求的参数是什么了。看一下ctx的属性吧: 123# ctx.request.__dict__&#123;'environ': &#123;'wsgi.errors': &lt;gunicorn.http.wsgi.WSGIErrorsWrapper object at 0x7f52c6bc0ac8&gt;, 'wsgi.version': (1, 0), 'wsgi.multithread': False, 'wsgi.multiprocess': False, 'wsgi.run_once': False, 'wsgi.file_wrapper': &lt;class 'gunicorn.http.wsgi.FileWrapper'&gt;, 'SERVER_SOFTWARE': 'gunicorn/19.9.0', 'wsgi.input': &lt;gunicorn.http.body.Body object at 0x7f52c6bc08d0&gt;, 'gunicorn.socket': &lt;socket.socket fd=9, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000), raddr=('127.0.0.1', 60598)&gt;, 'REQUEST_METHOD': 'GET', 'QUERY_STRING': '', 'RAW_URI': '///hello/flask', 'SERVER_PROTOCOL': 'HTTP/1.1', 'HTTP_HOST': '0.0.0.0:8000', 'HTTP_CONNECTION': 'keep-alive', 'HTTP_CACHE_CONTROL': 'max-age=0', 'HTTP_UPGRADE_INSECURE_REQUESTS': '1', 'HTTP_USER_AGENT': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/70.0.3538.77 Chrome/70.0.3538.77 Safari/537.36', 'HTTP_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'HTTP_ACCEPT_ENCODING': 'gzip, deflate', 'HTTP_ACCEPT_LANGUAGE': 'en-US,en;q=0.9,zh-CN;q=0.8,zh-TW;q=0.7,zh;q=0.6', 'wsgi.url_scheme': 'http', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '60598', 'SERVER_NAME': '0.0.0.0', 'SERVER_PORT': '8000', 'PATH_INFO': '///hello/flask', 'SCRIPT_NAME': '', 'werkzeug.request': &lt;Request 'http://0.0.0.0:8000/hello/flask' [GET]&gt;&#125;, 'shallow': False, 'view_args': &#123;'name': 'flask'&#125;, 'url_rule': &lt;Rule '/hello/&lt;name&gt;' (GET, OPTIONS, HEAD) -&gt; index&gt;, 'url': 'http://0.0.0.0:8000/hello/flask'&#125; 1&#123;'view_args': &#123;'name': 'flask'&#125;, 'url_rule': &lt;Rule '/hello/&lt;name&gt;' (GET, OPTIONS, HEAD) -&gt; index&gt;&#125; 这就是请求要访问的rule和请求的参数。 将请求上下文推入栈中1234567891011121314151617181920212223242526272829class RequestContext(object): def push(self): top = _request_ctx_stack.top if top is not None and top.preserved: top.pop(top._preserved_exc) # Before we push the request context we have to ensure that there # is an application context. app_ctx = _app_ctx_stack.top if app_ctx is None or app_ctx.app != self.app: app_ctx = self.app.app_context() app_ctx.push() self._implicit_app_ctx_stack.append(app_ctx) else: self._implicit_app_ctx_stack.append(None) if hasattr(sys, 'exc_clear'): sys.exc_clear() _request_ctx_stack.push(self) if self.session is None: session_interface = self.app.session_interface self.session = session_interface.open_session( self.app, self.request ) if self.session is None: self.session = session_interface.make_null_session(self.app) ctx被推入_request_ctx_stack中。 分派处理并得到响应123456789101112131415161718class Flask(_PackageBoundObject): def full_dispatch_request(self): \"\"\"Dispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling. .. versionadded:: 0.7 \"\"\" self.try_trigger_before_first_request_functions() try: request_started.send(self) rv = self.preprocess_request() if rv is None: rv = self.dispatch_request() except Exception as e: rv = self.handle_user_exception(e) return self.finalize_request(rv) 先是调用preprocess_request函数，执行所有要求在请求处理前要完成的函数，如果这一步有返回值的话，那么就不会调用dispatch_request来真正的处理请求了，否则就接着调用dispatch_request函数: 123456789101112def dispatch_request(self): req = _request_ctx_stack.top.request if req.routing_exception is not None: self.raise_routing_exception(req) rule = req.url_rule # if we provide automatic options for this URL and the # request came with the OPTIONS method, reply automatically if getattr(rule, 'provide_automatic_options', False) \\ and req.method == 'OPTIONS': return self.make_default_options_response() # otherwise dispatch to the handler for that endpoint return self.view_functions[rule.endpoint](**req.view_args) 从_request_ctx_stack找出我们刚刚压入的ctx对象的request属性，并据此找出请求的rule和rule.endpoint, 接下来就简单了，根据rule.endpoint从view_functions中找到对应的路由函数，并以view_args作为参数来调用，返回结果再由finalize_request处理: 1234567891011def finalize_request(self, rv, from_error_handler=False): response = self.make_response(rv) try: response = self.process_response(response) request_finished.send(self, response=response) except Exception: if not from_error_handler: raise self.logger.exception('Request finalizing failed with an ' 'error while handling an error') return response finalize_request的作用就是将视图函数的返回值转换成Response的实例对象, 并调用后处理函数对response进行处理。 响应发送给服务器123456789101112131415161718192021222324252627282930# werkzeug/wrappers.BaseResponse def get_wsgi_response(self, environ): \"\"\"Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is ``'HEAD'`` the response will be empty and only the headers and status code will be present. .. versionadded:: 0.6 :param environ: the WSGI environment of the request. :return: an ``(app_iter, status, headers)`` tuple. \"\"\" headers = self.get_wsgi_headers(environ) app_iter = self.get_app_iter(environ) return app_iter, self.status, headers.to_wsgi_list() def __call__(self, environ, start_response): \"\"\"Process this response as WSGI application. :param environ: the WSGI environment. :param start_response: the response callable provided by the WSGI server. :return: an application iterator \"\"\" app_iter, status, headers = self.get_wsgi_response(environ) start_response(status, headers) return app_iter 典型的WSGI调用方式. 至此，一个请求就处理完了。 撒花~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://johoo26.github.io/tags/Flask/"}],"keywords":[]},{"title":"beginner to Django 6","slug":"beginner-to-Django-6","date":"2018-11-22T14:55:46.000Z","updated":"2018-11-23T17:55:25.110Z","comments":true,"path":"2018/11/22/beginner-to-Django-6/","link":"","permalink":"https://johoo26.github.io/2018/11/22/beginner-to-Django-6/","excerpt":"","text":"接下来要讲的是定制Django自动生成的管理端页面。 12345678from django.contrib import adminfrom .models import Question, Choice# Register your models here.class QuestionAdmin(admin.ModelAdmin): fields = ['pub_date', 'question_text']admin.site.register(Question, QuestionAdmin) 继承ModelAdmin得到的类作为第二个位置参数传入register函数，可以对Question在管理端的表征做出改变。 12345678910111213# polls/admin.pyfrom django.contrib import adminfrom .models import Question, Choice# Register your models here.class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;'fields':['question_text', ]&#125;), ('Date information', &#123;'fields':['pub_date', ]&#125;) ]admin.site.register(Question, QuestionAdmin) 通过定义fieldsets, 可以将字段进行分块呈现，对于字段非常多的model尤其有用。 似乎忘了什么？我们还需要能够编辑Choice啊！ 简单的做法是参照Question进行注册： 1234567891011121314# polls/admin.pyfrom django.contrib import adminfrom .models import Question, Choice# Register your models here.class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;'fields':['question_text', ]&#125;), ('Date information', &#123;'fields':['pub_date', ]&#125;) ]admin.site.register(Question, QuestionAdmin)admin.site.register(Choice) 这样做固然可以，但是用起来就会发现很不方便，最好是能够在新建question的时候能够一并创建一批choices。 1234567891011121314151617181920# polls/admin.pyfrom django.contrib import adminfrom .models import Question, Choice# Register your models here.class ChoiceInline(admin.StackedInline): model = Choice extra = 3class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;'fields':['question_text', ]&#125;), ('Date information', &#123;'fields':['pub_date', ]&#125;) ] inlines = [ChoiceInline]admin.site.register(Question, QuestionAdmin) 这样的话，Django就知道Choice model 是在 Question model页面一并编辑的，并且总会提供3个空值供填写。 由于StackedInline过长，将其更改为TabularInline以更好地展示： 12345# polls/admin.pyclass ChoiceInline(admin.TabularInline): model = Choice extra = 3 OK, Choice的编辑定制到此为止，让我们去修改默认的Question展示页： 12345678# polls/admin.pyclass QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;'fields':['question_text', ]&#125;), ('Date information', &#123;'fields':['pub_date', ]&#125;) ] list_display = ('question_text', 'pub_date', 'was_published_recently') 通过定义list_display变量，指定页面需要展示的内容。而且，还可以通过点击头部进行排序。 不过有个小问题，was_published_recently 展示的是函数名， 而且还不能排序。通过在Question model中增加几个属性来解决该问题： 12345678910111213141516171819# polls/models.pyfrom django.db import modelsfrom django.utils import timezonefrom datetime import timedelta# Create your models here.class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') def __str__(self): return self.question_text def was_published_recently(self): return self.pub_date &gt; timezone.now() - timedelta(days=1) was_published_recently.admin_order_field = 'pub_date' was_published_recently.boolean = True was_published_recently.short_description = 'Published recently?' 在QuestionAdmin中增加list_filter变量，就可以通过pub_date来筛选了： 123# polls/admin.pylist_filter = ['pub_date'] 而search_fields变量则可以指定能用来进行搜索的字段： 123# polls/admin.pysearch_fields = ['question_text'] 页面左上角的标题是”Django administration”, 如何改为自己想要的东西呢？很简单，一个变量搞掂： 123# polls/admin.pyadmin.AdminSite.site_header = 'Polls Administration' 当然，这样只是改了polls这一个app的标题，其他app还是”Django administration”，如果想要整个项目都一起更改，就要多做几步了： 在manage.py所处目录下创建目录templates, 在templates中再创建目录admin; 修改settings.py的TEMPLATES变量，增加DIRS： 123456789101112131415TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 将django/contrib/admin/templates/admin/base_site.html复制到第一步创建的admin目录中； 修改base_site.html: 123&#123;% block branding %&#125;&lt;h1 id=\"site-name\"&gt;&lt;a href=\"&#123;% url 'admin:index' %&#125;\"&gt;Polls administration&lt;/a&gt;&lt;/h1&gt;&#123;% endblock %&#125;","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://johoo26.github.io/tags/Django/"}],"keywords":[]},{"title":"beginner to Django 5","slug":"beginner-to-Django-5","date":"2018-11-21T00:17:00.000Z","updated":"2018-11-22T14:49:09.114Z","comments":true,"path":"2018/11/21/beginner-to-Django-5/","link":"","permalink":"https://johoo26.github.io/2018/11/21/beginner-to-Django-5/","excerpt":"","text":"接下来要介绍静态文件的使用：添加CSS和背景图片。 django.contrib.staticfiles这个应用（在INSTALLED_APPS中）从每个应用中搜集静态文件并放到同一个位置以用于生产环境。Django的STATICFILES_FINDERS设置包含一系列用来搜寻静态文件的工具，其中默认的是AppDirectoriesFinder, 其会在每个应用中寻找叫做static的子目录。因此，在polls目录下建立一个子目录static, 出于名称空间的考虑，在其中再建立一个polls子目录，而后在子目录中创建文件style.css: 12345/* polls/static/polls/style.css */li a &#123; color: green;&#125; 接着将样式加到polls/templates/polls/index.htm中： 12&#123;% load static %&#125;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&#123;% static 'polls/style.css' %&#125;\"&gt; 启动服务，访问http://localhost:8000/polls/ 可以看到最新效果。 “% static %” 用于生成静态文件的绝对路经。 而后在polls/statis/polls中再建立一个子目录：images, 在其中放入一张图片:background.gif, 而后更新样式: 1234567li a &#123; color: green;&#125;body &#123; background: white url('images/background.gif') no-repeat;&#125; 启动服务，访问http://localhost:8000/polls/ ，可以看到背景图片展示在左上角。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://johoo26.github.io/tags/Django/"}],"keywords":[]},{"title":"beginner to Django 4","slug":"beginner-to-Django-4","date":"2018-11-19T05:16:28.000Z","updated":"2018-11-20T15:20:52.982Z","comments":true,"path":"2018/11/19/beginner-to-Django-4/","link":"","permalink":"https://johoo26.github.io/2018/11/19/beginner-to-Django-4/","excerpt":"","text":"接下来是处理表单请求，以及怎么样用更少的代码去实现视图。 改写polls/detail.html, 加上表单： 123456789101112&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;&lt;form action=\"&#123;% url 'polls:vote' question.id %&#125;\" method=\"post\"&gt;&#123;% csrf_token %&#125;&#123;% for choice in question.choice_set.all %&#125; &lt;input type=\"radio\" name=\"choice\" id=\"choice&#123;&#123; forloop.counter &#125;&#125;\" value=\"&#123;&#123; choice.id &#125;&#125;\"&gt; &lt;label for=\"choice&#123;&#123; forloop.counter &#125;&#125;\"&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br&gt;&#123;% endfor %&#125;&lt;input type=\"submit\" value=\"Vote\"&gt;&lt;/form&gt; 表单的意思就不解释了，懂点HTML就能看得懂。 “csrf_token”的作用是防止跨站伪造请求攻击。 以上表单数据通过POST方式发送到polls:vote这个url, 接着把对应的视图函数实现了： 123456789101112131415161718192021from django.shortcuts import render, get_object_or_404from django.http import HttpResponse, Http404, HttpResponseRedirectfrom django.urls import reversefrom .models import Question, Choice# Create your views here.def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): return render(request, 'polls/detail.html', &#123; 'question': question, 'error_message': \"You didn't select a choice!\" &#125;) else: selected_choice.votes += 1 selected_choice.save() return HttpResponseRedirect(reverse('polls:results', args=(question.id, ))) 通过从request.POST中找到表单传递进来的choiceID, 来找到selected_choice, 并将投票数增1. 要注意的一个地方是，处理完POST请求后一定要重定向到其他页面，防止用户反复提交表单。 reverse函数的作用是构建url。 由于要重定向到polls:results, 因此这里也要修改： 1234567891011from django.shortcuts import render, get_object_or_404from django.http import HttpResponse, Http404, HttpResponseRedirectfrom django.urls import reversefrom .models import Question, Choice# Create your views here.def result(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/results.html', &#123;'question': question&#125;) 相应的polls/results.html如下： 123456789&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&lt;a href=\"&#123;% url 'polls:detail' question.id %&#125;\"&gt;Vote again?&lt;/a&gt; 观察polls/views.py，可以发现index, detail, result这3个视图函数非常相似：根据url中的参数，从数据库中查询出相应结果，渲染模板得到响应。由于这种操作实在是太常见，Django提供了generic views(一般视图)这种方法来减少代码量。 首先修改视图： 12345678910111213141516171819202122232425from django.shortcuts import render, get_object_or_404from django.http import HttpResponse, Http404, HttpResponseRedirectfrom django.urls import reversefrom django.views import genericfrom .models import Question, Choice# Create your views here.class IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list' def get_queryset(self): return Question.objects.order_by('-pub_date')[:5]class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html'class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html' 然后修改polls/urls.py: 123456789101112from django.urls import pathfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.IndexView.as_view(), name='index'), path('&lt;int:pk&gt;/', views.DetailView.as_view(), name='detail'), path('&lt;int:pk&gt;/results/', views.ResultsView.as_view(), name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] ListView和DetailView分别查找“符合条件的对象组成的列表”和“符合条件的特定对象”。 DetailView根据url中pk参数的值去数据库中查找，所以把url中question_id替换成pk. DetailView默认查找的模板格式为：&lt;app_name&gt;/&lt;model_name&gt;_detail.html, 因为把我们想要用的模板传递给template_name参数来告诉Django用指定的模板。 DetailView默认用model名字来做上下文对象的名字，而ListView默认的上下文对象名字是:&lt;modelname_list&gt;, 即 question_list, 这显然和模板不符，因此定义context_object_name变量来改写这一问题。 说实话，我个人觉得这个generiv views并没有什么特别的优势吸引我使用。反而把简单的事情搞复杂了。见仁见智吧。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://johoo26.github.io/tags/Django/"}],"keywords":[]},{"title":"beginner to Django 3","slug":"beginner-to-Django-3","date":"2018-11-16T10:25:38.000Z","updated":"2018-11-16T12:08:19.506Z","comments":true,"path":"2018/11/16/beginner-to-Django-3/","link":"","permalink":"https://johoo26.github.io/2018/11/16/beginner-to-Django-3/","excerpt":"","text":"接下来进入视图部分。 在polls/views.py中创建几个view funcs: 1234567891011121314151617181920from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def index(request): return HttpResponse('Hello Django!')def detail(request, question_id): return HttpResponse('You are looking at question %s' % question_id)def result(request, question_id): return HttpResponse('You are looking at the result of question %s' % question_id)def vote(request, question_id): return HttpResponse('You are voting on question %s' % question_id) 然后在polls/urls.py中构建url到view func的映射： 12345678910from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'), path('&lt;int:question_id&gt;/', views.detail, name='detail'), path('&lt;int:question_id&gt;/results/', views.result, name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 然后分别访问http://localhost:8000/polls/1/， http://localhost:8000/polls/1/results/, http://localhost:8000/polls/1/vote/ 就可以看到对应结果了。 由于我们在settings.py中设置了ROOT_URLCONF = &#39;myproj.urls&#39;， 因此请求会首先找到myproj/urls.py, 在那里匹配到polls规则后，去掉这部分，转到polls/urls.py中来匹配，遍历urlpatterns中每一个path, 找到第一个匹配的path指定的view， 将request和对应参数传入，得到响应。所以path的顺序很重要。 OK，流程上应该没问题了，让我们加上模板系统，上点真材实料！ 首先，在polls目录下创建一个子目录templates。这是因为settings.py中设置TEMPLATES的backend为DjangoTemplates， 同时其APP_DIRS也设为True，而DjangoTemplates会在每一个INSTALLED_APPS的目录下寻找templates的子目录。 然后在templates下再创建一个polls的子目录。在其中新建index.html文件： 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=\"/polls/&#123;&#123; question.id &#125;&#125;/\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 修改视图函数index: 123456789101112131415from django.shortcuts import renderfrom django.http import HttpResponsefrom django.template import loaderfrom .models import Question# Create your views here.def index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] template = loader.get_template('polls/index.html') context = &#123; 'latest_question_list': latest_question_list, &#125; return HttpResponse(template.render(context, request)) 去http://localhost:8000/polls/ 就可以看到最近创建的5个问题了。 记不记得Flask渲染模板用的是render函数？没错，Django也有… 改写后的index, 方便多了。 123456def index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123; 'latest_question_list': latest_question_list, &#125; return render(request, 'polls/index.html', context) 如果请求的资源不存在，需要返回404异常的话： 1234567891011121314from django.shortcuts import renderfrom django.http import HttpResponse, Http404from .models import Question# Create your views here.def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404('Question donot exist.') else: return render(request, 'polls/detail.html', &#123;'question': question&#125;) 或者更快捷一点： 123456789from django.shortcuts import render, get_object_or_404from .models import Question# Create your views here.def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) 回到index视图，前面hardcode了一个地方： 1&lt;a href=\"/polls/&#123;&#123; question.id &#125;&#125;/\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt; 这样很不好，一旦url规则要改，全部都要改，有一个类似于Flask的url_for的方法： 1&lt;a href=\"&#123;% url 'detail' question.id %&#125;\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt; 能这么做的前提，是我们之前在配置url映射的时候，在path函数中设置了name 关键字参数： 1path('&lt;int:question_id&gt;/', views.detail, name='detail') 这样就不用担心url格式发生变化了。 但是实际生产环境的项目可能会有很多的apps，可能其他app中也有一个detail的视图，那怎么区分呢？ 办法很简单，namespace–名称空间。 添加应用的名称空间： 1234567891011121314# polls/urls.pyfrom django.urls import pathfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.index, name='index'), path('&lt;int:question_id&gt;/', views.detail, name='detail'), path('&lt;int:question_id&gt;/results/', views.result, name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 修改链接： 1&lt;a href=\"&#123;% url 'polls:detail' question.id %&#125;\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt; 启动服务，一切OK.","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://johoo26.github.io/tags/Django/"}],"keywords":[]},{"title":"beginner to Django 2","slug":"beginner-to-Django-2","date":"2018-11-16T07:01:41.000Z","updated":"2018-11-16T08:49:49.139Z","comments":true,"path":"2018/11/16/beginner-to-Django-2/","link":"","permalink":"https://johoo26.github.io/2018/11/16/beginner-to-Django-2/","excerpt":"","text":"今天要涉及的部分是数据库和模型，以及Django自带的admin管理端。 Django支持很多常见的数据库，我这里选择用MySQL。要能让Django与MySQL交互，Django官方推荐安装mysqlclient–直接pip安装即可。数据库配置在myproj/settings.py中： 1234567891011121314151617181920# Database# https://docs.djangoproject.com/en/2.1/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'db_django', 'USER': 'test', 'PASSWORD': 'test', 'HOST': 'localhost', 'PORT': '3306', 'OPTIONS': &#123; 'init_command': \"SET sql_mode='STRICT_TRANS_TABLES'\", &#125;, &#125;&#125;# 需要事先在MySQL中创建一个叫db_django的库，创建用户test,密码test,并授予其对应权限# 此外，Django强烈要求打开MySQL的strict-mode,我查了一下，这个确实很好用，会把很多# 错误的请求从原来仅仅给出warning调为直接error报错，安全级别更高了 顺便把时区改成自己的： 123# settings.pyTIME_ZONE = 'Asia/Shanghai' 注意到myproj/settings.py中这样一个变量： 12345678910# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 这些是Django默认自带的应用，因为这些基本上所有场景都会用到。如果不需要的话可以注释掉。由于以上apps中有些需要库表，所以执行以下命令进行迁移： 1(venv) myproj ❯ python manage.py migrate 然后就可以在db_django库中看到已经有对应的tables了： 123456789101112131415mysql test@localhost:db_django&gt; SHOW tables;+----------------------------+| Tables_in_db_django ||----------------------------|| auth_group || auth_group_permissions || auth_permission || auth_user || auth_user_groups || auth_user_user_permissions || django_admin_log || django_content_type || django_migrations || django_session |+----------------------------+ migrate命令的作用是根据模型进行数据库同步，它只会同步INSTALLED_APPS中的应用涉及到的库表。 现在开始创建模型。模型差不多可以认为是数据库的表，只不过能做的事情多得多。这里需要创建两个models: Question 和 Choice. 编辑 polls/models.py: 12345678910111213from django.db import models# Create your models here.class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 接下来要让models生效。首先在settings.py中添加我们的polls应用，这样迁移的时候才会执行。 123456789INSTALLED_APPS = [ 'polls.app.PollsConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 然后执行命令： 123456(venv) myproj ❯ python manage.py makemigrations pollsMigrations for 'polls': polls/migrations/0001_initial.py - Create model Choice - Create model Question - Add field question to choice makemigrations命令的作用是告诉Django我对models做了一些改变，需要存到migration中去。可以在polls/migrations/0001_initial.py查看对应内容。这个文件是可以改动的，达到手动控制Django迁移结果的目的。现在执行迁移并修改库表： 12345(venv) myproj ❯ python manage.py migrateOperations to perform: Apply all migrations: admin, auth, contenttypes, polls, sessionsRunning migrations: Applying polls.0001_initial... OK 在MySQL中可以看到创建了两张表：polls_choice, polls_question. 使用迁移最大的好处是可以不用手动去修改库表，尤其是线上环境，可以在不影响现有业务的前提下更新库表。 下面看看Django自带的admin管理端。 首先创建管理员用户： 1(venv) myproj ❯ python manage.py createsuperuser 按提示输入用户名，邮箱和密码即可。 然后在polls/admin.py中注册model - Question，告诉admin其可以在页面上被修改。 12345from django.contrib import adminfrom .models import Question, Choice# Register your models here.admin.site.register(Question) 启动服务后，在http://localhost:8000/admin/ 页面可以看到Question已经可以编辑了。真的是太方便了！","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://johoo26.github.io/tags/Django/"}],"keywords":[]},{"title":"beginner to Django 1","slug":"beginner-to-Django-1","date":"2018-11-08T15:56:23.000Z","updated":"2018-11-23T18:08:55.917Z","comments":true,"path":"2018/11/08/beginner-to-Django-1/","link":"","permalink":"https://johoo26.github.io/2018/11/08/beginner-to-Django-1/","excerpt":"","text":"最近在学习Django的使用，把相关的知识点记录下来，毕竟只有经历了比输出更残酷的输入，才算是真正掌握对应的知识点。Django和Flask是Python Web开发框架中使用最多的两个框架，两者最大的不同之处在于，Flask只提供一个强健的内核，而Django则尽可能把所有的工具都集成在自身中，即Battery-included.这样做的好处在于，你无须去互联网上找别人开发的扩展，毕竟扩展开发人员的水平无法保证，出了问题也不一定能得到解决，在Django这里，有一个出色的团队在开发和维护，一切都可控。Django的另一个优点是，规定了包的组织架构，特别适合一个团队一起开发项目时使用，而Flask则很考验开发人员自身的代码架构水平了，遇到水平参差不齐的同事的话，可能会比较痛苦。 OK，开始跟着Django官网的tutorial学习Django！ 首先创建一个项目project: 1❯ django-admin startproject myproj 会看到当前目录下多了一个myproj的目录，结构如下： 12345678910(venv) /tmp ❯ tree myproj myproj├── manage.py└── myproj ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py1 directory, 5 files manage.py是一个管理入口，所能做的事情其实和命令 django-admin 是一样的，但manage.py额外为我们做了这几件事： 将项目的包路经加到sys.path中 设置环境变量DJANGO_SETTINGS_MODULE，使其指向项目的settings.py 一般来说，单个项目开发的时候使用manage.py会更容易，而如果要在多个项目中跳转，则应使用django-admin. 里层的myproj目录则是实际的项目包。 myproj/settings.py中放置的是myproj项目的设置，myproj/urls.py是项目的url分配器，myproj/wsgi.py是WSGI服务器运行web_app的入口。 先启动试一下： 1(venv) myproj ❯ python manage.py runserver 就可以在http://127.0.0.1:8000/ 看到默认页面了。 需要指出的是，这里启动用的是Django内置的方便开发而设置的服务器，不能用于生产环境。 现在创建一个投票应用： 1(venv) myproj ❯ python manage.py startapp polls app 是一个项目中具体做事情的部分，项目中可以含有多个app， app也可以置于多个项目中。 app可以位于任何pythonpath内的路经，这里放在manage.py同一级只是为了导入方便。 看一下polls的内容： 12345678910(venv) myproj ❯ tree polls polls├── admin.py├── apps.py├── __init__.py├── migrations│ └── __init__.py├── models.py├── tests.py└── views.py startapp 命令自动帮我们生成以上文件，节省了开发人员设计的时间。是不是很方便？ 现在创建一个真正的视图。 12345678910# polls/views.pyfrom django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def index(request): return HttpResponse('Hello Django!') 要想访问到index视图函数，需要有url映射到这里来，在polls/views.py同级目录下创建urls.py模块，并写入如下内容： 123456789# polls/urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] path函数的第一个参数是route, 第二个参数是view func, 关键字参数name是为了便于动态构建url用的。 这样就可以了吗？当然不行，还在把polls/urls.py注册到myproj/urls.py中才行，因为myproj才是入口： 1234567891011121314151617181920212223242526272829# myproj/urls.py\"\"\"myproj URL ConfigurationThe `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/2.1/topics/http/urls/Examples:Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: path('', views.home, name='home')Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: path('', Home.as_view(), name='home')Including another URLconf 1. Import the include() function: from django.urls import include, path 2. Add a URL to urlpatterns: path('blog/', include('blog.urls'))\"\"\"from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls), ]# 上面介绍了3种添加路由的方法，Django推荐用 include， 只有一个例外: admin.# include函数会把匹配到的url截掉开头匹配的模式后传递给引入的url模块，这样的话# 前面匹配的模块就不会写死，可以根据需求任意调整成比如 'polls2/', 'fun-polls/'，# 视图函数完全不用任何改变。 启动server,然后就可以在 http://localhost:8000/polls/ 看到响应内容”Hello Django!”.","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://johoo26.github.io/tags/Django/"}],"keywords":[]},{"title":"正则表达式-扩展符号","slug":"正则表达式-扩展符号","date":"2018-05-07T15:20:54.000Z","updated":"2018-05-08T16:27:24.000Z","comments":true,"path":"2018/05/07/正则表达式-扩展符号/","link":"","permalink":"https://johoo26.github.io/2018/05/07/正则表达式-扩展符号/","excerpt":"","text":"Python re模块除了常用的几个函数外，还有一个功能强大的东西—扩展符号。(?iLmsux)“i”表示忽略大小写匹配,正如flags=re.IGNORECASE12In [42]: re.findall(r\"(?i)yes\", \"yes, Yes, YES\")Out[42]: ['yes', 'Yes', 'YES'] “m”表示把多行作为各个独立体而不是一个整体来判断，因此用^匹配的时候，两行都会命中。12345678In [49]: sOut[49]: 'the first line,\\nthis is second line'In [50]: re.findall(r\"^th\\w+\", s)Out[50]: ['the']In [51]: re.findall(r\"(?m)^th\\w+\", s)Out[51]: ['the', 'this'] “s”表示.可以匹配包括换行符在内的所有字符。12345678In [60]: sOut[60]: 'the first\\nthe second\\nthe third'In [61]: re.search(r\"the.*\", s).group()Out[61]: 'the first'In [62]: re.search(r\"(?s)the.*\", s).group()Out[62]: 'the first\\nthe second\\nthe third' “x”允许对匹配模式换行，加上注释等，使之更易读。1234567891011In [70]: phonenumberOut[70]: '(800) 555-1212'In [71]: re.match(r'''(?x)...: \\((\\d&#123;3&#125;)\\) #区号...: \\s+ #空白...: \\d&#123;3&#125; #前缀...: - #横线...: \\d&#123;4&#125; #尾号...: ''', phonenumber).group()Out[71]: '(800) 555-1212' (?:…) 可以对部分正则表达式分组，但是并不会保存该分组用于后续的检查或者应用12345678In [3]: sOut[3]: 'http://google.com http://www.google.com http://code.google.com'In [4]: re.findall(r\"http://(\\w+\\.)?(\\w+\\.com)\", s)Out[4]: [('', 'google.com'), ('www.', 'google.com'), ('code.', 'google.com')]In [5]: re.findall(r\"http://(?:\\w+\\.)?(\\w+\\.com)\", s)Out[5]: ['google.com', 'google.com', 'google.com'] (?P)通过名称来保存匹配到的分组12345In [11]: re.search(r\"(?P&lt;year&gt;\\d&#123;4&#125;)-(?P&lt;month&gt;\\d&#123;1,2&#125;)-(?P&lt;day&gt;\\d&#123;1,2&#125;)\", \"2018-5-8\").groupdict()Out[11]: &#123;'year': '2018', 'month': '5', 'day': '8'&#125;In [12]: re.sub(r\"(?P&lt;year&gt;\\d&#123;4&#125;)-(?P&lt;month&gt;\\d&#123;1,2&#125;)-(?P&lt;day&gt;\\d&#123;1,2&#125;)\", \"\\g&lt;month&gt;-\\g&lt;day&gt;-\\g&lt;year&gt;\",\"2018-5-8\")Out[12]: '5-8-2018' 在sub函数中可以通过”\\g&lt;year>“表示匹配到的分组year，而不用\\num来表示。(?=…)123In [13]: re.findall(r\"\\w+ (?=van Rossum)\", \"Guido van Rossum, Just van Rossum, Kay Ring\")Out[13]: ['Guido ', 'Just ']\"\\w+ (?=van Rossum)\"模式，表示只有后接\"van Rossum\"的\"\\w+ \"才匹配。 (?!…)123456In [22]: re.findall(r\"Emma (?!test)\", \"Emma test, Emma Snow, Emma Hu\")Out[22]: ['Emma ', 'Emma ']In [23]: re.findall(r\"Emma \", \"Emma test, Emma Snow, Emma Hu\")Out[23]: ['Emma ', 'Emma ', 'Emma ']\"Emma (?!test)\"模式 ，表示只有后面不是接\"test\"的\"Emma \"才会匹配。","categories":[{"name":"编程","slug":"编程","permalink":"https://johoo26.github.io/categories/编程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://johoo26.github.io/tags/Python/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://johoo26.github.io/categories/编程/"}]},{"title":"简单总结一下近期学习的shell脚本编程","slug":"简单总结一下近期学习的shell脚本编程","date":"2018-05-01T06:58:47.000Z","updated":"2018-05-01T11:29:07.000Z","comments":true,"path":"2018/05/01/简单总结一下近期学习的shell脚本编程/","link":"","permalink":"https://johoo26.github.io/2018/05/01/简单总结一下近期学习的shell脚本编程/","excerpt":"","text":"花了点时间把《The Linux command line》这本书最后部分看完了—shell脚本编程，总结于此，加深印象。 脚本第一行需要告诉操作系统用什么解释器来执行我们的脚本，即shebang:#!/bin/bash定义变量，”=”两边不能有空格，使用变量需要加上前缀”$”来展开: foo=emma echo $foo shell函数,定义语法有两种： a)function name { commands return } b)name () { commands return }函数的定义必须在使用之前，因此最好在脚本开头把函数全部定义好。局部变量： foo=0 func1 () { local foo foo=1 echo “func1:foo = $foo” } func2 () { local foo foo=2 echo “func2:foo = $foo” } echo “global: foo = $foo” func1 echo “global: foo = $foo” func2 echo “global: foo = $foo”运行结果： jo@Arch  ~  hello.sh global: foo = 0 func1:foo = 1 global: foo = 0 func2:foo = 2 global: foo = 0可见，在函数内通过local命令可以定义局部变量，局部变量仅对其所在的函数起作用。Shell Functions In Your .bashrc Fileshell函数完美的替代了别名，并且实际上是创建个人所用的小命令的首选方法。别名非常局限于命令的种类和它们支持的shell功能，然而 shell函数允许任何可以编写脚本的东西。例如，如果我们喜欢为我们的脚本开发的这个 report_disk_space shell 函数，我们可以为我们的.bashrc 文件 创建一个相似的名为 ds 的函数： ds () { echo “Disk Space Utilization For $HOSTNAME” df -h }分支选择 分支选择有两种方法，if..else 和 case，分别介绍：if..else语法形式： if [condition];then commands elif [contidion];then commands else commands ficase..esac语法形式： case word in pattern1) commands;; pattern2) commands;; esac Test 命令 文件表达式 表达式 如果下列条件为真则返回True file1 -ef file2 file1和file2拥有相同的索引号（通过硬连接两个文件指向相同的文件 file1 -nt file2 file1新于file2 file1 -ot file2 file1早于filt2 -b file file存在并且是一个块（设备）文件 -c file file存在奶并且是一个字符（设备）文件 -d file file存在且为目录 -e file file存在 -f file file存在且是一个普通文件 -g file file存在且设置了组ID -G file file存在且由有效组ID拥有 -L file file存在且是一个符号链接 -p file file存在且是一个命名管道 -r file file存在且可读 -s file file存在且其长度大于零 -S file file存在且是一个网络socket -w file file存在且可写 -x file file存在且可执行 字符串表达式 表达式 如果下列条件为真则返回True string string不为null -n string 字符串string的长度大于零 -z string 字符串string的长度为零 string1 == string2 两个字符串相等，此处用单等号也可以，不过推荐== string1 != string2 两个字符串不等 string1 &gt; string2 string1排列在string2之后 string1 &lt; string2 string1排列在string2之前 整型表达式 表达式 如果为真 int1 -eq int2 相等 int1 -ne int2 不等 int1 -lt int2 int1小于int2 int1 -le int2 int1小于等于int2 int1 -gt int2 int1大于int2 int1 -ge int2 int1大于等于int2 Compound Command 复合命令[[ expression ]]支持test所有表达式 ，但是增加了正则匹配：string1 =~ pattern因此能用这种就尽量用这种。 (())–为整数设计专门用于执行整数之间的操作，变量可以不用展开，直接使用名字 逻辑操作符 操作符 测试 [[]] and (())AND -a &amp;&amp;OR -o ||NOT ! ! 控制操作符：分支的另一种方法很酷的用法，也可以进行防卫性编程。cmd1 &amp;&amp; cmd2先执行cmd1，并且只有cmd1执行成功才会执行cmd2cmd1 || cmd2先执行cmd1，只有cmd1执行失败才会执行cmd2 读取键盘输入使用read命令读取键盘输入，语法： read [-options] [variables…]如果没提供变量名，shell变量REPLY会包含所有数据行。IFS通常shell对输入按空格，tab，换行符进行切分，可以通过更改IFS对输入进行分离： IFS=”:” read value1 value1 &lt;&lt;&lt; “$info”You can’t Pipe read, 你不能把管道用你在read上 循环控制循环有三种方式：while语法： while condition;do commands doneuntil语法： until contidion;do commands donewhile 和 until两者的区别：while在contidion成立时循环，直到不成立时退出；until相反。forfor循环有两种：1. for i in a b c d;do echo $i done2. for ((i=0; i&lt;5; ++i));do echo $i done跳出循环的命令break和continue，和Python机理相同。 位置参数 $0表示脚本完整名字，$1,$2等等表示用来表示位置参数。shift命令可以向后移动一次$1的指向，原来的$2变成$1,对于多个输入参数的处理很有用。 数组创建数组的方式：1. arr[1]=”foo” arr[2]=”bar” 2.arr=(“foo” “bar”) 简单的shell脚本没啥问题了，更复杂的还要实际生产中去历练。不过目前工作中shell基本用不到太高深的东西，所以这些基本上也够了，主要精力要用来熟悉并掌握linux环境下的开发，部署，维护上。新买了一本《Linux Shell脚本攻略》，好好研读。而这本《The Linux Command Line》的网页版，刚好可以利用地铁上的时间来重温复习一遍。","categories":[{"name":"编程","slug":"编程","permalink":"https://johoo26.github.io/categories/编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://johoo26.github.io/tags/Linux/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://johoo26.github.io/categories/编程/"}]},{"title":"Introduction to tcpdump","slug":"Introduction-to-tcpdump","date":"2018-04-29T09:08:22.000Z","updated":"2018-04-29T10:10:58.000Z","comments":true,"path":"2018/04/29/Introduction-to-tcpdump/","link":"","permalink":"https://johoo26.github.io/2018/04/29/Introduction-to-tcpdump/","excerpt":"","text":"网络编程出异常的时候，常用的调试办法一定包含抓包。抓取请求和响应的内容，才能定位问题出在哪里。这几天学习了一下tcpdump命令，不得不说，简直是抓包神器啊。下面开始正文。 man手册中介绍tcpdump：dump traffic on a network.顾名思义，就是抓取网络中信息流。 我经常用的选项：-A: 以ASCII形式打印抓到的每一个包，但是如果加密了就没办法-c: 后面接数字，抓到指定数量包后就退出-i: 指定监听的网络接口。一般用”-i any”表示监听所有网络接口的数据-nn: 不要把主机地址和端口转换成名字，即保留数字形式-r: 读取文件-s: 限定包的长度，”-s 0”表示抓取完整长度的包-tttt: 打印人类可读的时间-vvv: 使包的信息尽可能详细-w: 把抓到的包写入文件中-X: 以16进制和ASCII的形式输出 还可以指定主机，端口，网络：host: 指定主机port: 指定端口net: 指定网络src: 包来源dst: 包目的地 还可以用逻辑表达式组合一系列选项：“and” “or” “not” tcpdump一般的输出形式： src &gt; dst: Flags [tcpflags], seq data-seqno, ack ackno, win window, urg urgent, options [opts], length len 以我目前的水平只能解释到这里了，man手册后半部分比较深入，由于自己对TCP的原理还不够了解，看不太明白…以上基本的用法掌握了，对于工作中遇到的大部分问题其实也够用了。后续有时间再好好研读HTTP权威指南等大部头，彻底搞懂网络请求的每一个细节！","categories":[{"name":"编程","slug":"编程","permalink":"https://johoo26.github.io/categories/编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://johoo26.github.io/tags/Linux/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://johoo26.github.io/categories/编程/"}]},{"title":"给博客搬家啦","slug":"给博客搬家啦","date":"2018-04-28T17:18:33.000Z","updated":"2018-04-29T05:26:00.000Z","comments":true,"path":"2018/04/29/给博客搬家啦/","link":"","permalink":"https://johoo26.github.io/2018/04/29/给博客搬家啦/","excerpt":"","text":"之前学狗书的时候用flask + heroku 做了一个简易博客，实在是太简陋了一些，因此决定迁移到github.io.一是免费，二是部署简洁，三是有很多现成的优美主题可供选择。以后要经常在博客上记录学到的东西，有益于对知识的进一步掌握和理解。加油！这段时间心无旁骛的提高自己。不要在杂事上耗费心神了，提高到一定程度再去想，否则只是浪费时间自取其辱罢了。时不我待！","categories":[{"name":"Life","slug":"Life","permalink":"https://johoo26.github.io/categories/Life/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://johoo26.github.io/tags/生活/"}],"keywords":[{"name":"Life","slug":"Life","permalink":"https://johoo26.github.io/categories/Life/"}]}]}